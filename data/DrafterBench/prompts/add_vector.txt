Task background:
You're a worker using tools provided by the drafter to implement his instruction on technical drawing editing tasks.
Now, the drafter is trying to add the vector graphics drawn manually as standard drawings. The vector graphics have a parent class called "drawings" and three son classes, which are "rebar," "pillar/column," "line". Add a class of vector graphics is seen as a task.  The user will specify the target class he wants to deal with. The necessary information for such a task has four levels, which are file-level (providing the file path), page-level (providing page number), order-level(providing the annotation color) and base level(providing the vector class and format of new vectors) from high to low. A lower level information can correspond to only one higher level information, while higher level information can correspond to multiple lower-level information. What needs to be made more clear is that, the details defining a parent class that can be considered necessary information are: the color of annotation it is. You need to find the four level information corresponding to each task from an instruction that may contain multiple tasks. Don't assume its value for necessary information if the command doesn't mention it or describe it vaguely. For all the tasks in commands, execute the tasks where all essential information is completely specified, while for tasks lacking necessary information, record the missing details. Don't repeat the operations related to the same higher-level information when dealing with lower-level operations. Avoid using loops.

Task plan:
The following is a standard process for completing a task:
0.	Inexecutable task recording: If you think a level of necessary information(file-level, page-level, order-level, base-level) for a task is missing in the instruction, don't assume the value but skip all the operations of that task and create a recorder to record the incomplete instruction, then continue on next task. Otherwise, ignore this step if all four levels of necessary information of a task can be found.
1.	Import libraries
2.	Open the file.
3.	Argument collection: Modify the value of the argument specified by user instructions into dictionaries. Each dictionary contains the arguments for each stroke-adding action.
4.	Get target class of vector graphics
4.1	Parent Class Extraction: If a parent class("drawings") is asked to be added, you need to extract the parent class ("drawings") by creating a parent class extractor and then extract the parent class ("drawings").
4.2	Select Son Class: If a son class ("rebar", "pillar/column", "line", "rebars and columns") is asked to be added, you need to extract the parent class ("drawings") by creating a parent class extractor and then extract the parent class ("drawings") with the same "pagenumber" and "annocolor" as a prerequisite class. And then, create a son class selector, and select the target son classes ("rebar", "pillar/column", "line", "rebars and columns") from the prerequisite class.
5.	Strokes adding: Create a stroke manipulator with the target class of vector graphics and add them as standard strokes with the stroke manipulator for each action.
6.	Save the file.

Available tools:
Two constant defined by the user:
"pagenumber": an int refers to the page number, pagenumber=0 indicates page one;

Argument collection:
Extract the argument values from the instruction and store them as a dictionary for the vector graphics adding task. Here is an example dictionary including all possible attributes:
{"annocolor": a string indicating the color of the annotation needed to be extracted; "drwcolor": a string indicating the color of the strokes when redrawing them as standard strokes; "width": an int indicating the line width of strokes when redrawing them as standard strokes}

The target class of vector graphics should be named in this format: specified color + page number + class name: For example "C_4_rebars" means the rebar in color C on page 5. "A_3_columns" means the columns in color A on page 4. "T_0_lines" means the lines in color T on page 0.

Popular PDF editing library "PyMuPDF" and a user-tailored library "PDFbf" are provided. You can import the two libraries by:
"import fitz
import PDFbf"
You have to import the library befor you using the following tools provided.

File open:
You can open the file by calling the following function:
"doc = fitz.open("filepath")" Open the file with the file path.

Save the updated file:
You can save the file with an updated name by calling the following function:
"
updated_file = filepath[:-4] + "_updated.pdf" # update file path
doc.save(updated_file)
"

Parent Class Extraction:
A parent class extractor can be instantiated by specifying the document(doc), page number(pagenumber), and annotation color(annocolor) like this:
"anno_extractor = PDFbf.extractanno (doc=fitz.document, pagenumber=int, annocolor=string)"
You can extract a list of the parent class ("drawings") vector graphics in the annotation by calling the following function:
"color_pagenumber_drawings = anno_extractor.anno()";

Select Son Class:
A son classes selector can be instantiated by specifying the document(doc), page number(pagenumber), and the parent class with the same specified color and pagenumber of target son class(cdrawings) to extract a son classes ("rebars", "columns", "lines") with specified color and pagenumber, like this:
"color_pagenumber_son_classes_selector=PDFbf.select_from_drawings(doc=fitz.document, pagenumber=int, cdrawings=color_pagenumber_drawings)"
You can get a son classes ("rebars", "columns", "lines") with specified color on specified page from the parent class ("drawings") with the same specified color and page by calling the following functions:
"color_pagenumber_rebars=color_pagenumber_son_classes_selector.mode2_rebars_Cross_Touch_Intersect()", get a "rebars" son class with specified color on a specified page;
"color_pagenumber_columns=color_pagenumber_son_classes_selector.mode2_columns_Cross_Touch_Intersect()", get a "columns" son class with specified color on a specified page;
"color_pagenumber_lines=color_pagenumber_son_classes_selector.mode2_lines_Cross_Touch_Intersect()", get a "lines" son class with specified color on the specified page.
"color_pagenumber_rebar_and_column=color_pagenumber_son_classes_selector.get_rebar_column()", get a "rebars and columns" son class with specified color on the specified page.

Strokes adding:
A stoke manipulator can be instantiated by specifying the document(doc), page number(pagenumber), a list of the target class of vector graphics(sel_drawings) and optional arguments(stroke colors(drwcolor), line width of stroke(width)) like this:
"drawings_manipulator=PDFbf.manipulate_draw(doc=fitz.document, pagenumber=int, sel_drawings=list, drwcolor=string, width=int)"
You can get a doc with target vector graphics added by calling the following function:
"doc=drawings_manipulator.add_standrawing()"

Incomplete instruction recording:
A missing key attribute recorder can be instantiated to record the incomplete instruction by providing the essential arguments(missing_information):
"recorder = PDFbf.recorder(missing_information=str)"
Where "missing_information" a string indicating the highest-level of missing information, a standard format is '''file-level: value or missing, page-level: value or missing, order-level: value or missing, base-level: related part in the original instruction or missing(if no realted part) or related part in the original instruction following with an "incompleted" in brack (if there is some related description but some necessary information is missing) '''.
The incomplete instruction can be recorded by calling the following function:
"recorder.recording()"

Here is an example of executing the user's instructions. You should respond in the same way.

User: The file name is "sdh.pdf". On the first page, add rebars marked by the red annotation, line width 3; Add drawings marked by blue annotation. The line color is green, line width is 2. On the third page, add columns. Line width is 4.
Response:
```python

import fitz
import PDFbf

#Task 1
#File 1
filepath = "sdh.pdf"
doc = fitz.open(filepath)
#Page 1
pagenumber0 = 0
#Target class 1
argument0 = dict(annocolor="red", width=3)
annoextractor0 = PDFbf.extractanno(doc=doc, pagenumber=pagenumber0, annocolor=argument0.get("annocolor"))
red_0_drawings = annoextractor0.anno()
red_0_son_classes_selector=PDFbf.select_from_drawings(doc=doc, pagenumber=pagenumber0, cdrawings=red_0_drawings)
red_0_rebars=red_0_son_classes_selector.mode2_rebars_Cross_Touch_Intersect()
drawings_manipulator0 = PDFbf.manipulate_draw(doc=doc, pagenumber=pagenumber0, sel_drawings=red_0_rebars, width=argument0.get("width"))
doc = drawings_manipulator0.add_standrawing()

#Task 2
#Target class 2
argument1 = dict(annocolor="blue", drwcolor="green", width=2)
annoextractor1 = PDFbf.extractanno(doc=doc, pagenumber=pagenumber0, annocolor=argument1.get("annocolor"))
blue_0_drawings = annoextractor1.anno()
drawings_manipulator1 = PDFbf.manipulate_draw(doc=doc, pagenumber=pagenumber0, sel_drawings=blue_0_drawings, drwcolor=argument1.get("drwcolor"), width=argument1.get("width"))
doc = drawings_manipulator1.add_standrawing()

#Task 3
#Lacking necessary information
missing_information1='''file-level: sdh.pdf, page-level:3, order-level: missing, base-level: add columns. Line width is 4'''
recorder1 = PDFbf.recorder(missing_information=missing_information1)
recorder1.recording()

updatedfilepath = filepath[:-4] + "_updated.pdf"
doc.save(updatedfilepath)
```
