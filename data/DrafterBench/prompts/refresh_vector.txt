Task background:
You're a high-level programmer. You are writing code to help a drafter implement construction drawings editing tasks.
Now, the drafter is trying to update the vector graphics format on the target area boxed by rectangle markups. The vector graphics have a parent class called "drawings" and three son classes, which are "rebar," "column," "line". There are two selection modes to select target class vectors, which are:  1. Window/Cover/Enclosure mode: the vector will be selected only if all vertices and boundaries of the graphic are covered within the rectangular checkbox, 2 Cross/Touch/Intersect mode: the vector will be selected if any of the vertices and a boundary of the vector are within the rectangular checkbox. There are all possible format attributes that the drafter may want to change: stroke color, line type (dash or straight), close path, fill color, joint type, cap type, and stroke width. Updating a group of vectors on a target position with a corresponding group of format attributes is seen as a task. The necessary information for such a task has four levels, which are file-level (providing the file path), page-level (providing page number), order-level (providing rectangle order on the page), and base-level(providing the classes of vectors to be updated and providing the details for at least one of the format attributes correspondingly) from high to low. A lower level information can correspond to only one higher level information, while higher level information can correspond to multiple lower-level information. What needs to be clarified is that the details defining a target class that can be considered necessary information are the class and the selection mode. You need to find the necessary information corresponding to each task from an instruction that may contain multiple tasks to complete the execution of the instruction. Don't assume the value of missing necessary information (only the value of the format attribute mentioned but not specified value explicitly can be assumed), but identify tasks lacking necessary information, record the missing details, and execute the task only once all essential information is gathered. Don't repeat the operations related to the same higher-level information when dealing with lower-level operations. Avoid using loops.

Task plan:
The following is a standard process for completing a task:
0.	Inexecutable task recording: If you think a level of necessary information(file-level, page-level, order-level, base-level) for a task is missing in the instruction, don't assume the value but skip all the operations of that task and create a recorder to record the incomplete instruction, then continue on next task. Otherwise, ignore this step if all four levels of necessary information of a task can be found.
1.	Import libraries
2.	Open the file.
3.	Target position extraction: Crate an annotation extractor and extract the rectangles on the target page and order.
4.	Argument collection: Prepare parameters for updating vectors on a target position by modifying the argument's value specified by the drafter's instructions into a dictionary.
5.	Target class(es) selection: Create a drawing selector and select the specified vector graphics(drawings, lines, rebars, columns) with the specified selection mode by the selector.
6.	Updating vectors: Create a vector manipulating instance and update vectors.
7.	Save the file.

Available tools:
Two constant defined by the user:
"pagenumber": an int refers to the page number, pagenumber=0 indicates page one;
"rectangleorder" an int refers to the order of rectangles within the page, rectangleorder=0 indicates the first rectangle;

Argument collection:
Extract the argument values from the instruction and store them as a dictionary for the vector updating task. Here is an example dictionary including all possible attributes:
{"clip": a rectangle boxes the drawings that needed to be dealt with; "fillcolor": a string refers to the fill color; "drwcolor": a string refers to the color of the drawing; "dashes": a sting refers to the dashed line, the general format is "[n m] 0", n is an int indicting the dash length, m (optional) is an int indicting the subsequent gap length, and 0 is an int specifying no pixels should be skipped before the dashing starts, if a dashed line is required, but no parameters are specified, take "[3 3]0", if a straight line is required, the parameters should be "[0 0]0"; "closePath": a bool indicating whether the path is a close path; "lineJoin": an int controlling the way how line connections look like. This may be either as a sharp join (0), a rounded join (1), or a cut-off join(2);" lineCap": an int controlling the look of line ends. the options are sharp ends(0), semi-circle ends(1), and semi-square ends(2); "width": an int refers to the line width of drawings}

Popular PDF editing library "PyMuPDF" and a user-tailored library "PDFbf" are provided. You can import the two libraries by:
"import fitz
import PDFbf"
You have to import the library befor you using the following tools provided.

File open:
You can open the file by calling the following function:
"doc = fitz.open("filepath")" Open the file with the file path.

Save the updated file:
You can save the file with an updated name by calling the following function:
"
updated_file = filepath[:-4] + "_updated.pdf" # update file path
doc.save(updated_file)
"

Target position extraction:
An annotation extractor is instantiated by providing the essential arguments document(doc):
"annoextractor = PDFbf.extractanno(doc=fitz.document)"
Get a rectangle and its reference points:
"rectangle, rfpoint = annoextractor.getclip_rfpoint(pagenumber=int,rectangleorder=int)"


Target class(es) selection:
A vectors selector can be instantiated by specifying the document(doc), page number(pagenumber), and clip like this:
"selector = PDFbf.selector(doc=fitz.document, pagenumber=int, clip=rectangle)"
The selector is to select a subgroup from drawings with two optional selection modes. The subgroup can be described by the type of vector graphics ("drawings", "lines", "rebars", or "columns"). There are two selection modes: 1. Window/Cover/Enclosure mode: the vector will be selected only if all vertices and boundaries of the graphic are completely within the rectangular checkbox, 2 Cross/Touch/Intersect mode: the vector will be selected if any of the vertices and a boundary of the vector are within the rectangular checkbox.
Choose the selection specified or closest to the description of the subgroup.
You can get a list of a subgroup with a specified selection mode by calling these functions:
"covered_drawings = selector.mode1_drawings_Window_Cover_Enclosure()" select drawings with selection mode 1;
"intersected_drawings = selector.mode2_drawings_Cross_Touch_Intersect()" select drawings with selection mode 2;
"covered_lines = selector.mode1_lines_Window_Cover_Enclosure()" select lines with selection mode 1;
"intersected_lines = selector.mode2_lines_Cross_Touch_Intersect()" select lines with selection mode 2;
"covered_rebars= selector.mode1_rebars_Window_Cover_Enclosure()" select rebars with selection mode 1;
"intersected_rebars = selector.mode2_rebars_Cross_Touch_Intersect()" select rebars with selection mode 2;
"covered_columns = selector.mode1_columns_Window_Cover_Enclosure()" select columns with selection mode 1;
"intersected_columns = selector.mode2_columns_Cross_Touch_Intersect()" select columns with selection mode 2;


Updating vectors:
A vector manipulator is instantiated by specifying the essential arguments (document(doc), page number(pagenumber), selected drawings(sel_drawings)) and optional arguments (fill color (fillcolor), drawing color(drwcolor), dashes line (dashes), close path or not (closePath), line joint shape (lineJoin), line end shape (lineCap), line width (width)) on demand like this:
"manipulator=PDFbf.manipulate_draw(doc=doc,pagenumber=int,sel_drawings=list,fillcolor=string,drwcolor=string,dashes=string,closePath=bool,lineJoin=int,lineCap=int,width=int)"
You can get a doc with the list of drawings refreshed by calling the following function:
"doc = manipulator.update_draw()"

Incomplete instruction recording:
A missing key attribute recorder can be instantiated to record the incomplete instruction by providing the essential arguments(incomplete_instruction, missing_information):
"recorder = PDFbf.recorder(missing_information=str)"
Where "missing_information" is a string indicating the highest-level of missing information, a standard format is '''file-level: value or missing, page-level: value or missing, order-level: value or missing, base-level: related part in the original instruction or missing(if no realted part) or related part in the original instruction following with an "incompleted" in brackets (if there is some related description but some necessary information is missing) '''.
The incomplete instruction can be recorded by calling the following function:
"recorder.recording()"

Here is an example. You should respond in the same way.

User: The file name is "fjhgdf.pdf". For the third box on page two, change the columns intersecting with the box to red, dash lines with rounded line joints; change the line covered by the box to a dashed line and line width 3. For the eighth box on page one, change the lines intersecting with the box to yellow filling, close path, semi-square line end; change the rebars covered by the box to blue with a dashed line and line width 3. For the fifth box on page ten, change the columns covered by the box to green with a semi-square line end and line width 4; change the rebars intersecting with the box.

Response:
```python

import fitz
import PDFbf
filepath = "fjhgdf.pdf"
doc = fitz.open(filepath)

annoextractor = PDFbf.extractanno(doc)

# Mission 1
pagenumber0=1
rectangleorder0=2
rectangle0, rfpoint0 = annoextractor.getclip_rfpoint(pagenumber=pagenumber0, rectangleorder=rectangleorder0)
argument0=dict(clip=rectangle0,drwcolor="red",dashes="[3,3]0",lineJoin=1)
selector0 = PDFbf.selector(doc=doc,pagenumber=pagenumber0,clip=argument0.get("clip"))
intersected_columns0 = selector0.mode2_columns_Cross_Touch_Intersect()
manipulator0=PDFbf.manipulate_draw(doc=doc,pagenumber=pagenumber0,sel_drawings=intersected_columns0,drwcolor=argument0.get("drwcolor"),dashes=argument0.get("dashes"),lineJoin=argument0.get("lineJoin"))
doc = manipulator0.update_draw()

argument1=dict(clip=rectangle0,dashes="[3,3]0",width=3)
covered_lines1 = selector0.mode1_lines_Window_Cover_Enclosure()
manipulator1=PDFbf.manipulate_draw(doc=doc,pagenumber=pagenumber0,sel_drawings=covered_lines1,dashes=argument1.get("dashes"),width=argument1.get("width"))
doc = manipulator1.update_draw()

pagenumber1=0
rectangleorder1=7
rectangle1, rfpoint1 = annoextractor.getclip_rfpoint(pagenumber=pagenumber1, rectangleorder=rectangleorder1)
argument2=dict(clip=rectangle1,fillcolor="yellow",closePath=True,lineCap=2)
selector1 = PDFbf.selector(doc=doc,pagenumber=pagenumber1,clip=argument2.get("clip"))
intersected_lines2 = selector1.mode2_lines_Cross_Touch_Intersect()
manipulator2=PDFbf.manipulate_draw(doc=doc, pagenumber=pagenumber1, sel_drawings=intersected_lines2, fillcolor =argument2.get("fillcolor"), closePath=argument2.get("closePath"), lineCap=argument2.get("lineCap"))
doc = manipulator2.update_draw()

argument3 = dict(clip=rectangle1, drwcolor="blue", dashes="[3 3]0", width=3)
covered_rebars3 = selector1.mode1_rebars_Window_Cover_Enclosure()
manipulator3 = PDFbf.manipulate_draw(doc=doc, pagenumber=pagenumber1, sel_drawings=covered_rebars3, drwcolor=argument3.get("drwcolor"), dashes=argument3.get("dashes"), width=argument3.get("width"))
doc = manipulator3.update_draw()

# Mission 3
pagenumber2 = 9
rectangleorder2 = 4
rectangle2, rfpoint2 = annoextractor.getclip_rfpoint(pagenumber=pagenumber2, rectangleorder=rectangleorder2)
argument4 = dict(clip=rectangle2, drwcolor="green", lineCap=2, width=4)
selector2 = PDFbf.selector(doc=doc, pagenumber=pagenumber2, clip=argument4.get("clip"))
covered_columns4 = selector2.mode1_columns_Window_Cover_Enclosure()
manipulator4 = PDFbf.manipulate_draw(doc=doc, pagenumber=pagenumber2, sel_drawings=covered_columns4, drwcolor=argument4.get("drwcolor"), lineCap=argument4.get("lineCap"), width=argument4.get("width"))
doc = manipulator4.update_draw()

missing_information5='''file-level: fjhgdf.pdf, page-level:10, order-level:5, base-level: change the rebars intersecting with the box (incomplete)'''
recorder5 = PDFbf.recorder(missing_information=missing_information5)
recorder5.recording()

updatedfilepath = filepath[:-4] + "_updated.pdf"
doc.save(updatedfilepath)
```
