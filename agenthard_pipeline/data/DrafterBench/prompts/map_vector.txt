Task background:
You're a high-level programmer. You are writing code to help a drafter implement construction drawings editing tasks.
Now, the drafter is trying to map the vector graphics on the target area boxed by rectangle markups. The vector graphics have a parent class called "drawings" and three son classes, which are "rebar," "column," "line". There are two selection mode to select target class vectors, which are:  1. Window/Cover/Enclosure mode: the vector will be selected only if all vertices and boundaries of the graphic are covered within the rectangular checkbox, 2 Cross/Touch/Intersect mode: the vector will be selected if any of the vertices and a boundary of the vector are within the rectangular checkbox. There are three operations that the drafter may want: translation, rotation, and scaling, the details defining the operation including operation type, direction and magnitude. Deleting a group of vectors on a target position with a corresponding group of operations is seen as a task. The necessary information for such a task has four levels, which are file-level (providing the file path), page-level (providing page number), order-level (providing rectangle order on the page), and base-level(providing the classes of vectors to be mapped and providing the details for at least one of the three operations correspondingly) from high to low. A lower level information can correspond to only one higher level information, while higher level information can correspond to multiple lower-level information. What needs to be made more clear is that, the details defining a target class that can be considered necessary information are: the class and the selection mode. You need to find the necessary information corresponding to each task from an instruction that may contain multiple tasks to complete the execution of the instruction. Don't assume the value of missing necessary information (only the magnitude of operation can be assumed), but identify tasks lacking necessary information, record the missing details, and execute the task only once all essential information is gathered. Don't repeat the operations related to the same higher-level information when dealing with lower-level operations. Avoid using loops.

Task plan:
The following is a standard process for completing a task:
0.	Inexecutable task recording: If you think a level of necessary information(file-level, page-level, order-level, base-level) for a task is missing in the instruction, don't assume the value but skip all the operations of that task and create a recorder to record the incomplete instruction, then continue on next task. Otherwise, ignore this step if all four levels of necessary information of a task can be found.
1.	Import libraries
2.	Open the file.
3.	Target position extraction: Crate an annotation extractor and extract the rectangles on the target page and order.
4.	Argument collection: Prepare parameters for mapping vectors on a target position by modifying the argument's value specified by the drafter's instructions into a dictionary.
5.	Target class(es) selection: Create a drawing selector and select the specified vector graphics(drawings, lines, rebars, columns) with the specified selection mode by the selector.
6.	Mapping vectors: Create a vectors projector instance and map vectors.
7.	Save the file.

Available tools:
Two constant defined by the user:
"pagenumber": an int refers to the page number, pagenumber=0 indicates page one;
"rectangleorder" an int refers to the order of rectangles within the page, rectangleorder=0 indicates the first rectangle;


Argument collection:
Extract the argument values from the instruction and store them as a dictionary for the table position-changing task. Here is an example dictionary including all possible attributes:
{"clip": a rectangle boxes the text that need to be dealt with; "move": a list refers to translation details, general form: [move in its right direction (positive value if move right, negative value if move left), move in its upper direction (positive value if move up, negative value if move down), reference_point], "rotation": a list refers to the rotation details, general form: ['r', rotation degrees in the clockwise direction (positive value in clockwise direction, negative value in counterclockwise direction),reference_point], if the direction of rotation is not specified, clockwise is considered; "scal": a list refers to the scaling, general form: ['sc', [zoom factor X direction, zoom factor Y direction], reference_point]}

Popular PDF editing library "PyMuPDF" and a user-tailored library "PDFbf" are provided. You can import the two libraries by:
"import fitz
import PDFbf"
You have to import the library befor you using the following tools provided.

File open:
You can open the file by calling the following function:
"doc = fitz.open("filepath")" Open the file with the file path.

Save the updated file:
You can save the file with an updated name by calling the following function:
"
updated_file = filepath[:-4] + "_updated.pdf" # update file path
doc.save(updated_file)
"

Target position extraction:
An annotation extractor is instantiated by providing the essential arguments document(doc):
"annoextractor = PDFbf.extractanno(doc=fitz.document)"
Get a rectangle and its reference points
"rectangle, rfpoint = annoextractor.getclip_rfpoint(pagenumber=int,rectangleorder=int)"

Target class(es) selection:
A vectors selector can be instantiated by specifying the document(doc), page number(pagenumber), and clip like this:
"selector = PDFbf.selector(doc=fitz.document, pagenumber=int, clip=rectangle)"
The selector is to select a subgroup from drawings with two optional selection modes. The subgroup can be described by the type of vector graphics ("drawings", "lines", "rebars", or "columns"). There are two selection modes: 1. Window/Cover/Enclosure mode: the vector will be selected only if all vertices and boundaries of the graphic are completely within the rectangular checkbox, 2 Cross/Touch/Intersect mode: the vector will be selected if any of the vertices and a boundary of the vector are within the rectangular checkbox.
Choose the selection specified or closest to the description of the subgroup.
You can get a list of a subgroup with a specified selection mode by calling these functions:
"covered_drawings = selector.mode1_drawings_Window_Cover_Enclosure()" select drawings with selection mode 1;
"intersected_drawings = selector.mode2_drawings_Cross_Touch_Intersect()" select drawings with selection mode 2;
"covered_lines = selector.mode1_lines_Window_Cover-Enclosure()" select lines with selection mode 1;
"intersected_lines = selector.mode2_lines_Cross_Touch_Intersect()" select lines with selection mode 2;
"covered_rebars= selector.mode1_rebars_Window_Cover_Enclosure()" select rebars with selection mode 1;
"intersected_rebars = selector.mode2_rebars_Cross_Touch_Intersect()" select rebars with selection mode 2;
"covered_columns = selector.mode1_columns_Window_Cover_Enclosure()" select columns with selection mode 1;
"intersected_columns = selector.mode2_columns_Cross_Touch_Intersect()" select columns with selection mode 2;

Mapping vectors:
A vector projector is instantiated by specifying the essential arguments (document(doc), page number(pagenumber), clip, selected drawings(sel_drawings),cdrawings(cdrawings)) and optional arguments (movement of translation (move), rotation(rotation) and scaling(scal)) on demand like this:
"projector=PDFbf.project_draw(doc=fitz.document,pagenumber=int,clip=rectangle,sel_drawings=list, cdrawings=list, move=[move_in_right_direction, move_in_up_direction, reference_point],rotation=['r', rotation degrees in clockwise direction,reference_point],scal=['sc',[zoom factor X direction, zoom factor Y direction], reference_point])"
You can get a doc with the drawings mapped by calling the following function:
"doc = projector.project()"
"cdrawings" can be obtained by calling the selector like this "selector.selected_lines",

Incomplete instruction recording:
A missing key attribute recorder can be instantiated to record the incomplete instruction by providing the essential arguments(missing_information):
"recorder = PDFbf.recorder(missing_information=str)"
Where "missing_information" a string indicating the highest-level of missing information, a standard format is '''file-level: value or missing, page-level: value or missing, order-level: value or missing, base-level: related part in the original instruction or missing(if no realted part) or related part in the original instruction following with an "incompleted" in brackets (if there is some related description but some necessary information is missing) '''.
The incomplete instruction can be recorded by calling the following function:
"recorder.recording()"

Here is an example. You should respond in the same way.

User: The file name is "fjhgdf.pdf". For the eighth box on page one, rotate the drawing covered by the box 45 degrees clockwise; move the rebars intersected with the box 50 units left, 20 units down. For the second box on page five, scale the columns intersected with the box 0.8 times in both x and y directions; rotate the rebars covered by the box 45 degrees counterclockwise and move it 30 units left, 20 units up and scal it 0.8 times in x direction, 1.2 times in y firection. For the first box on page seven, scale the rebars covered by the box 1.5 times in both x and y directions; move the lines covered by the box 20 units right, 10 units up, and rotate it.

Response:
```python

import fitz
import PDFbf

filepath = "fjhgdf.pdf"
doc = fitz.open(filepath)

annoextractor = PDFbf.extractanno(doc=doc)

pagenumber0=0
rectangleorder0=7
rectangle0, rfpoint0 = annoextractor.getclip_rfpoint(pagenumber=pagenumber0,rectangleorder=rectangleorder0)
argument0=dict(clip=rectangle0, rotation=['r', 45, rfpoint0])
selector0 = PDFbf.selector(doc=doc,pagenumber=pagenumber0,clip=argument0.get("clip"))
covered_drawings0 = selector0.mode1_drawings_Window_Cover_Enclosure()
projector0 = PDFbf.project_draw(doc=doc, pagenumber=pagenumber0, clip=argument0.get("clip"), sel_drawings=covered_drawings0, cdrawings=selector0.selected_lines, move=argument0.get("rotation"))
doc = projector0.project()

argument1=dict(clip=rectangle0, move=[-50,-20, rfpoint0])
intersected_rebars1 = selector0.mode2_rebars_Cross_Touch_Intersect()
projector1 = PDFbf.project_draw(doc=doc, pagenumber=pagenumber0, clip=argument1.get("clip"), sel_drawings=intersected_rebars1, cdrawings=selector0.selected_lines, rotation=argument1.get("move")ï¼‰
doc = projector1.project()


pagenumber1 = 4
rectangleorder1 = 1
rectangle1, rfpoint1 = annoextractor.getclip_rfpoint(pagenumber=pagenumber1,rectangleorder=rectangleorder1)
argument2 = dict(clip=rectangle1, scal=['sc', [0.8, 0.8], rfpoint1])
selector1 = PDFbf.selector(doc=doc, pagenumber=pagenumber1, clip=argument2.get("clip"))
intersected_columns2 = selector1.mode2_columns_Cross_Touch_Intersect()
projector2 = PDFbf.project_draw(doc=doc, pagenumber=pagenumber1, clip=argument2.get("clip"), sel_drawings=intersected_columns2, cdrawings=selector1.selected_lines, scal=argument2.get("scal"))
doc = projector2.project()

argument3 = dict(clip=rectangle1, move=[-30, 20, rfpoint1], rotation=['r', -45, rfpoint1], scal=['sc', [0.8, 1.2], rfpoint1])
covered_rebars3 = selector1.mode1_rebars_Window_Cover_Enclosure()
projector3 = PDFbf.project_draw(doc=doc, pagenumber=pagenumber1, clip=argument3.get("clip"), sel_drawings=covered_rebars3, cdrawings=selector1.selected_lines, rotation=argument3.get("rotation"), move=argument3.get("move"), scal=argument3.get("scal"))
doc = projector3.project()

pagenumber2 = 6
rectangleorder2 = 0
rectangle2, rfpoint2 = annoextractor.getclip_rfpoint(pagenumber=pagenumber2,rectangleorder=rectangleorder2)
argument4 = dict(clip=rectangle2, scal=['sc', [1.5, 1.5], rfpoint2])
selector2 = PDFbf.selector(doc=doc, pagenumber=pagenumber2, clip=argument4.get("clip"))
covered_rebars4 = selector2.mode1_rebars_Window_Cover_Enclosure()
projector4 = PDFbf.project_draw(doc=doc, pagenumber=pagenumber2, clip=argument4.get("clip"), sel_drawings=covered_rebars4, cdrawings=selector2.selected_lines, scal=argument4.get("scal"))
doc = projector4.project()

missing_information5='''file-level: fjhgdf.pdf, page-level:7, order-level:1, base-level: move the lines covered by the box 20 units right, 10 units up, and rotate it (incomplete)'''
recorder5 = PDFbf.recorder(missing_information=missing_information5)
recorder5.recording()

updatedfilepath = filepath[:-4] + "_updated.pdf"
doc.save(updatedfilepath)
```
