Task background:
You're a worker using tools provided by the drafter to implement his instruction on technical drawing editing tasks.
Now, the drafter wants to edit the text content on the target area boxed by rectangle markups. Editing text on a target position is seen as a task. There are two possible operations must be select one: deleting and replacing. There are also format attributes that can be optionally specified on demand: the font, font size, alignment, text color, and rotation. The necessary information for such a task has four levels, which are file-level (providing the file path), page-level (providing page number), order-level (providing rectangle order on the page), and base-level(providing the necessary information of the operation) from high to low. The first three levels of information determine the target position, while the base level describes the operation. A lower level information can correspond to only one higher level information, while higher level information can correspond to multiple lower-level information. You need to find the four level information corresponding to each task from an instruction that may contain multiple tasks. Don't assume its value for necessary information if the command doesn't mention it or describe it vaguely. For all the tasks in commands, execute the tasks where all essential information is completely specified, while for tasks lacking necessary information, record the missing details. Don't repeat the operations related to the same higher-level information when dealing with lower-level operations. Avoid using loops.


Task plan:
The following is a standard process for completing a task:
0.	Inexecutable task recording: If you think a level of necessary information(file-level, page-level, order-level, base-level) for a task is missing in the instruction, don't assume the value but skip all the operations of that task and create a recorder to record the incomplete instruction, then continue on next task. Otherwise, ignore this step if all four levels of necessary information of a task can be found.
1.	Import libraries
2.	Open the file.
3.	Target position extraction: Crate an annotation extractor and extract the rectangles on the target page and order.
4.	Argument collection: Prepare parameters for updating text content by modifying the argument's value specified by the drafter's instructions into a dictionary.
5.	Update text content: Create a text manipulator instance for each text editing task, then extract the original text, revise the text content, and add new text to cover the original text.
6.	Save the file.

Available tools:
Two constant defined by the user:
"pagenumber": an int refers to the page number, pagenumber=0 indicates page one;
"rectangleorder" an int refers to the order of rectangles within the page, rectangleorder=0 indicates the first rectangle;

Argument collection:
Extract the argument values from the instruction and store them as a dictionary for the text editing task. Here is an example dictionary including all possible attributes:
{"clip": a rectangle boxes the text that needed to be revised;  "font": a string refers to the font of the text; "fontsize": an int refers to the font size; "align": a constant get by ```fitz.TEXT_ALIGN_RIGHT``` or ```fitz.TEXT_ALIGN_LEFT``` or ```fitz.TEXT_ALIGN_CENTER``` or ```fitz.TEXT_ALIGN_JUSTIFY``` refers to the alignment of the text in box; "rotate": an int in 0, or 90 refers to the direction of the original text to be edited, 0 means horizontal text, 90 means vertical text, if the direction of the text is not mentioned, the text is horizontal;}

Popular PDF editing library "PyMuPDF" and a user-tailored library "PDFbf" are provided. You can import the two libraries by:
"import fitz
import PDFbf"

File open:
You can open the file by calling the following function:
"doc = fitz.open("filepath")" Open the file with the file path.

Save the updated file:
You can save the file with an updated name by calling the following function:
"
updated_file = filepath[:-4] + "_updated.pdf" # update file path
doc.save(updated_file)
"
Target position extraction:
An annotation extractor is instantiated by providing the essential arguments document(doc):
"annoextractor = PDFbf.extractanno(doc=fitz.document)"
Get a rectangle and its reference points:
"rectangle, rfpoint = annoextractor.getclip_rfpoint(pagenumber=int,rectangleorder=int)"


Update text content:
A text manipulator is instantiated by specifying arguments (document(doc), page number(pagenumber), clip) and optional arguments (font, fontsize, text color, rotate, align) that mentioned like this:
"Text_manipulator=PDFbf.manipulate_text(doc=fitz.document,pagenumber=int,clip=rectangle,font=string,fontsize=int,textcolor=string,rotate=int,align=fitz.TEXT_ALIGN_LEFT)"
You can extract the original horizontal text by calling the following function:
"Text_manipulator.text=Text_manipulator.gethortext()"
You can get a string of original vertical text by calling the following function:
"Text_manipulator.text=Text_manipulator.getvertext()"

Here are some arguments that should be specified when you want to delete or replace specified texts from the original texts:
"deltex": a string refers to the text the user wants to delete from the original text;
"retext": a string refers to the text the user wants to replace from the original text;
"totext": a string refers to the text the user wants to use to replace the original text;

You can delete specified text from the string of original text by defining the text to delete(deltex), and calling the following function:
"Text_manipulator.text = Text_manipulator.deletetext(deltex=string)"
"Text_manipulator.text = Text_manipulator.deletetext(deltex="target text")" delete the text "target text".
"Text_manipulator.text = Text_manipulator.deletetext()" delete all the text if a delete action is required with no deltext specified.

You can replace specified text with certain text for the string of original text by defining the text to replace(retext), text used to replace(totext) and calling the following function:
"Text_manipulator.text = Text_manipulator.replacetext(retext=string, totext=string)"
"Text_manipulator.text = Text_manipulator.replacetext(retext="old", totext="new")" replace the text "old" using text "new".
"Text_manipulator.text = Text_manipulator.replacetext(totext="1236")" replace all the text using text "1236" if a replacement action is required with no retext specificed.
You can get a doc with original text covered by manipulated new text added by calling the following functions:
"doc = Text_manipulator.addtext()"

Incomplete instruction recording:
A missing key attribute recorder can be instantiated to record the incomplete instruction by providing the essential arguments(missing_information):
"recorder = PDFbf.recorder(missing_information=str)"
Where "missing_information" is a string indicating the highest-level of missing information, a standard format is '''file-level: value or missing, page-level: value or missing, order-level: value or missing, base-level: related part in the original instruction or missing(if no related part) or related part in the original instruction following with an "incomplete" in a brace (if there is some related description but some necessary information is missing) '''.
The incomplete instruction can be recorded by calling the following function:
"recorder.recording()"

Here is an example of executing the user's instructions. You should respond in the same way to execute the user's new instructions.

User: The file name is "42Del9iutete_text.pdf". For the text in the second box of page 5, delete "temporary and text". Replace the text with "assignment". Use left align. Font size 8.
For the text in the fourth box of page 12, replace "manager" with "supervisor". Delete "completed" and "new".
For the text in page 18, replace "due" with "scheduled". Delete "soon". Font size 12.

Response:
```python

import fitz
import PDFbf

#Task 1
#File 1
filepath = "42Del9iutete_text.pdf"
doc = fitz.open(filepath)
annoextractor = PDFbf.extractanno(doc=doc)
#Page 1
pagenumber0 = 4
#Rectangle 1
rectangleorder0 = 1
rectangle0, rfpoint0 = annoextractor.getclip_rfpoint(pagenumber=pagenumber0,rectangleorder=rectangleorder0)
#Operation 1
argument0 = dict(clip=rectangle0, align=fitz.TEXT_ALIGN_LEFT, fontsize=8)
Text_manipulator0 = PDFbf.manipulate_text(doc=doc, pagenumber=pagenumber0, clip=argument0.get("clip"), align=argument0.get("align"), fontsize=argument0.get("fontsize"))
Text_manipulator0.text = Text_manipulator0.gethortext()
Text_manipulator0.text = Text_manipulator0.deletetext(deltex="temporary and text")
Text_manipulator0.text = Text_manipulator0.replacetext(totext="assignment")
doc = Text_manipulator0.addtext()

#Task 2
#Page 2
pagenumber1 = 11
#Rectangle 2
rectangleorder1 = 3
rectangle1, rfpoint1 = annoextractor.getclip_rfpoint(pagenumber=pagenumber1,rectangleorder=rectangleorder1)
#Operation 2
argument1 = dict(clip=rectangle1)
Text_manipulator1 = PDFbf.manipulate_text(doc=doc, pagenumber=pagenumber1, clip=argument1.get("clip"))
Text_manipulator1.text = Text_manipulator1.gethortext()
Text_manipulator1.text = Text_manipulator1.replacetext(retext="manager", totext="supervisor")
Text_manipulator1.text = Text_manipulator1.deletetext(deltex="completed")
Text_manipulator1.text = Text_manipulator1.deletetext(deltex="new")
doc = Text_manipulator1.addtext()

#Task 3
#Lacking necessary information
missing_information2='''file-level:42Del9iutete_text.pdf,page-level:18,order-level:missing,base-level:replace "due" with "scheduled". Delete "soon". Font size 12.'''
recorder2 = PDFbf.recorder(missing_information=missing_information2)
recorder2.recording()

updatedfilepath = filepath[:-4] + "_updated.pdf"
doc.save(updatedfilepath)
```
